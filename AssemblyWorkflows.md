# Identifying novel SMGCs using de novo assembly

This workflow is designed to help you find novel SMGCs in de novo assembled strains, and also to identify polymorphisms like changes in cluster location and cluster fusions.

I recommend downloading the scripts in AssemblyScripts to a folder and adding that to your PATH. Python scripts assume Python2 version 2.7 or later and require BioPython.

**Step 0.** Prepare a reference genome - download GFF, protein files, mRNA files, genome, and a genbank file if you can find one (necessary for antiSMASH). Run [antiSMASH](https://antismash.secondarymetabolites.org/#!/download). Make sure you are running antiSMASH with the reference genome's gene calls - the built-in gene predictor in antiSMASH can produce suboptimal results. If you don't have a genbank file, you will have to make one. Depending on the type of input file you have, you will likely have to make some changes to the genbank generator script for it to work.

Relevant scripts:
```
convert_augustus_gff_and_fasta_to_gbk.py
```

**Step 1.** Assemble your genome(s) in whatever way seems best to you. [SPAdes](http://cab.spbu.ru/software/spades/) seems to do well with haploid fungal genomes. Don't forget to evaluate with [BUSCO](https://busco.ezlab.org/) and [QUAST](http://bioinf.spbau.ru/quast).

**Step 1a (optional).** Run [RepeatMasker](http://www.repeatmasker.org/) to identify transposable elements and mask repetitve regions for gene calling.

**Step 2.** Make gene calls on your de novo assembled genome. All downstream scripts of this assume you have done this with [Augustus](http://bioinf.uni-greifswald.de/augustus/) and are working with Augustus formatted GFFs.

If there is an Augustus config file for your species of interest, great! Use that. If not, you can try training Augustus on your reference genome. There are many ways to do this - the easiest way I know is by using the [BUSCO pipeline](https://busco.ezlab.org/). Alternatively, try a closely related species with an existing Augustus config. Keep in mind that computational gene prediction is never perfect, especially when you're not using any external evidence like RNA-seq or ESTs.
```
augustus -species=[species] [genome.fa] > [genes.gff]
```
Get coding sequences of these genes using [gffread](https://github.com/gpertea/gffread)
```
gffread [genes.gff] -x [cds.fa] -g [genome.fa]
```

**Step 3.** Determine orthologous genes between your newly annotated de novo genome and the reference genome. Since you're working with one species, I find reciprocal best blast to be a quick and relatively accurate way to do this. You can either do this with your nucleotide coding sequences or translate your coding sequences to amino acids and go from there. For this, you need the [BLAST command line suite](ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/).

```
translate_nucl_to_prot_fasta.py [cds.fa] > [prot.fa]
makeblastdb -dbytpe prot -in [ref_prots.fa]
makeblastdb -dbtype prot -in [prot.fa]
blastp -query [prot.fa] -db [ref_prots.fa] -outfmt 6 -num_threads [desired_cores] -out [strain_vs_ref_prots.bls]
blastp -query [ref_prots.fa] -db [prot.fa] -outfmt 6 -num_threads [desired_cores] -out [ref_prots_vs_strain.bls]
reciprocal_best_blast.py [strain_vs_ref_prots.bls] [ref_prots_vs_strain.bls] 1 2 12 high > [strain_reference_rbh.txt]
```

**Step 4.** Use the reciprocal best blast output to rename uninformative Augustus gene names.

Generate new names
```
rename_genes_blast.py [strainname] [cds.fa] [genes.gff] > [genenames.txt]
```

Rename GFF (this only changes things on the gene feature line, not mRNA, exon, CDS, etc - I only do this so I can generate an ordered list of genes later on)
```
rename_gff.py [genenames.txt] [genes.gff] > [genes_renamed.gff]
```

Rename CDS and protein files
```
rename_fasta.py [genenames.txt] [cds.fa] > [cds_renamed.fa]
rename_fasta.py [genenames.txt] [prot.fa] > [prot_renamed.fa]
```

Print an ordered list of genes along with start and end coords and strand from renamed GFF
```
list_genes_by_scaff.py [genes_renamed.gff] > [genes_in_order.txt]
```

**Step 5**. Generate a genbank file for antiSMASH. This might be the most painful part of this process. Ultimately, you need a Genbank file that can be parsed by the BioPython Genbank parser, because that's what antiSMASH will use. I have a script that converts renamed Augustus-formatted GFFs (generated by this specific workflow) that should make a BioPython-parseable genbank file. The second script, remove_geneless_scaffs.py, both removes geneless scaffolds (which can throw errors in antiSMASH) and also tests that the file is BioPython parseable. If this doesn't work for your data, check out the comments in the first script - you may be able to change things around to fit your input data.

```
convert_augustus_gff_and_fasta_to_gbk.py [genome.fa] [genes_renamed.gff] [prot_renamed.fa] > [genome.gbk]
remove_geneless_scaffs.py [genome.gbk] > [genome_clean.gbk]
```

**Step 6**. Run antiSMASH. I don't recommend using their ClusterFinder algorithm. The specific options are up to you, but I recommend you run it with full output options so you can visualize clusters using their html output if you want. The ClusterBlast/KnownClusterBlast output is also helpful. Our 2018 paper was done with antiSMASH version 3, and there's now a version 4, so I can't speak to differences there.

**Step 7.** Format your cluster output data and explore your results.


 antiSMASH gives you a file called geneclusters.txt that I like to reformat.
 
 ```
 antismash_parse.py geneclusters.txt > [strainname_geneclusters.txt]
 ```
 
 You should now have a list of secondary metabolic gene clusters in your strain of interest, along with their reciprocal best blast hits in your reference genome. These are some things I recommend you start looking at. This is just intended as a jumping off point for your analyses.
 
1. Are there gene clusters that have no orthologous hits to your reference genome? Make sure these genes are really not present in your reference genome by doing something like BLASTing the genes against the reference genome. Alternatively, are there gene clusters with genes with no hits in the reference genome that antiSMASH predicts to be biosynthetic genes?

If they're definitely not in the reference genome, you might have a novel cluster. Look at the cluster in the antiSMASH html output - what kind of cluster is it? Does it hit known clusters in the antismash knownclusterblast? Try searching sequence databases (like NCBI nr) with these genes to identify their origins.

Look at the flanking sequences of this gene cluster using the [genes_in_order.txt] file. Is this an insertion into a long chromosome, or is it on an unplaced small contig? If it's a small contig, it could be contamination - an insertion in the middle of a large contig is less likely to be contamination.

2. Look at the flanking sequences of each gene cluster. Are these the same flanking regions as in the reference genome, or are they different? If different, there may be a change in genomic location of this cluster.
